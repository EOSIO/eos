// TODO: this file duplicates a CDT file

// clang-format off
#pragma once
#include <eosio/datastream.hpp>
#include <eosio/name.hpp>
#include <eosio/varint.hpp>

#include <eosio/to_key.hpp>

#include <algorithm>
#include <cctype>
#include <functional>

#define EOSIO_CDT_GET_RETURN_T(value_class, index_name) std::decay_t<decltype(std::invoke(&value_class::index_name, std::declval<const value_class*>()))>

/**
 * @brief Macro to define an index.
 * @details In the case where the autogenerated index names created by DEFINE_TABLE are not enough, a user can instead
 * manually define the table and indices. This macro allows users to conveniently define an index without having to specify
 * the index template type, as those can be large/unwieldy to type out.
 *
 * @param index_name    - The index name.
 * @param member_name   - The name of the member pointer used for the index. This also defines the index's C++ variable name.
 */
#define KV_NAMED_INDEX(index_name, member_name)                                                                        \
   index<EOSIO_CDT_GET_RETURN_T(value_type, member_name)> member_name{eosio::name{index_name}, &value_type::member_name};

namespace eosio {
   namespace internal_use_do_not_use {

#ifdef __eosio_cdt__

#define IMPORT extern "C" __attribute__((eosio_wasm_import))

   // clang-format off
   IMPORT void     kv_erase(uint64_t db, uint64_t contract, const char* key, uint32_t key_size);
   IMPORT void     kv_set(uint64_t db, uint64_t contract, const char* key, uint32_t key_size, const char* value, uint32_t value_size);
   IMPORT bool     kv_get(uint64_t db, uint64_t contract, const char* key, uint32_t key_size, uint32_t& value_size);
   IMPORT uint32_t kv_get_data(uint64_t db, uint32_t offset, char* data, uint32_t data_size);
   IMPORT uint32_t kv_it_create(uint64_t db, uint64_t contract, const char* prefix, uint32_t size);
   IMPORT void     kv_it_destroy(uint32_t itr);
   IMPORT int32_t  kv_it_status(uint32_t itr);
   IMPORT int32_t  kv_it_compare(uint32_t itr_a, uint32_t itr_b);
   IMPORT int32_t  kv_it_key_compare(uint32_t itr, const char* key, uint32_t size);
   IMPORT int32_t  kv_it_move_to_end(uint32_t itr);
   IMPORT int32_t  kv_it_next(uint32_t itr);
   IMPORT int32_t  kv_it_prev(uint32_t itr);
   IMPORT int32_t  kv_it_lower_bound(uint32_t itr, const char* key, uint32_t size);
   IMPORT int32_t  kv_it_key(uint32_t itr, uint32_t offset, char* dest, uint32_t size, uint32_t& actual_size);
   IMPORT int32_t  kv_it_value(uint32_t itr, uint32_t offset, char* dest, uint32_t size, uint32_t& actual_size);
   // xclang-format on

#undef IMPORT

#endif
   }

#ifdef __eosio_cdt__
class kv_environment {
  public:
    kv_environment() {}

    void kv_set(const std::vector<char>& k, const std::vector<char>& v) {
        internal_use_do_not_use::kv_set(k.data(), k.size(), v.data(), v.size());
    }

    // clang-format off
    void     kv_erase(uint64_t db, uint64_t contract, const char* key, uint32_t key_size)                                       {return internal_use_do_not_use::kv_erase(db, contract, key, key_size);}
    void     kv_set(uint64_t db, uint64_t contract, const char* key, uint32_t key_size, const char* value, uint32_t value_size) {return internal_use_do_not_use::kv_set(db, contract, key, key_size, value, value_size);}
    bool     kv_get(uint64_t db, uint64_t contract, const char* key, uint32_t key_size, uint32_t& value_size)                   {return internal_use_do_not_use::kv_get(db, contract, key, key_size, value_size);}
    uint32_t kv_get_data(uint64_t db, uint32_t offset, char* data, uint32_t data_size)                                          {return internal_use_do_not_use::kv_get_data(db, offset, data, data_size);}
    uint32_t kv_it_create(uint64_t db, uint64_t contract, const char* prefix, uint32_t size)                                    {return internal_use_do_not_use::kv_it_create(db, contract, prefix, size);}
    void     kv_it_destroy(uint32_t itr)                                                                                        {return internal_use_do_not_use::kv_it_destroy(itr);}
    int32_t  kv_it_status(uint32_t itr)                                                                                         {return internal_use_do_not_use::kv_it_status(itr);}
    int32_t  kv_it_compare(uint32_t itr_a, uint32_t itr_b)                                                                      {return internal_use_do_not_use::kv_it_compare(itr_a, itr_b);}
    int32_t  kv_it_key_compare(uint32_t itr, const char* key, uint32_t size)                                                    {return internal_use_do_not_use::kv_it_key_compare(itr, key, size);}
    int32_t  kv_it_move_to_end(uint32_t itr)                                                                                    {return internal_use_do_not_use::kv_it_move_to_end(itr);}
    int32_t  kv_it_next(uint32_t itr)                                                                                           {return internal_use_do_not_use::kv_it_next(itr);}
    int32_t  kv_it_prev(uint32_t itr)                                                                                           {return internal_use_do_not_use::kv_it_prev(itr);}
    int32_t  kv_it_lower_bound(uint32_t itr, const char* key, uint32_t size)                                                    {return internal_use_do_not_use::kv_it_lower_bound(itr, key, size);}
    int32_t  kv_it_key(uint32_t itr, uint32_t offset, char* dest, uint32_t size, uint32_t& actual_size)                         {return internal_use_do_not_use::kv_it_key(itr, offset, dest, size, actual_size);}
    int32_t  kv_it_value(uint32_t itr, uint32_t offset, char* dest, uint32_t size, uint32_t& actual_size)                       {return internal_use_do_not_use::kv_it_value(itr, offset, dest, size, actual_size);}
    // xclang-format on
};
#endif

namespace detail {
   constexpr inline size_t max_stack_buffer_size = 512;

   template <typename V>
   static void serialize(const V& value, void* buffer, size_t size) {
      datastream<char*> ds((char*)buffer, size);
      unsigned_int i{0};
      ds << i;
      ds << value;
   }

   template <typename... Vs>
   static void serialize(const std::variant<Vs...>& value, void* buffer, size_t size) {
      datastream<char*> ds((char*)buffer, size);
      ds << value;
   }

   template <typename V>
   static void deserialize(V& value, void* buffer, size_t size) {
      unsigned_int idx;
      datastream<const char*> ds((char*)buffer, size);

      ds >> idx;
      eosio::check(idx==unsigned_int(0), "there was an error deserializing this value.");
      ds >> value;
   }

   template <typename... Vs>
   static void deserialize(std::variant<Vs...>& value, void* buffer, size_t size) {
      datastream<const char*> ds((char*)buffer, size);
      ds >> value;
   }

   template <typename V>
   static size_t get_size(const V& value) {
      auto size = pack_size(value);
      return size + 1;
   }

   template <typename... Vs>
   static size_t get_size(const std::variant<Vs...>& value) {
      auto size = pack_size(value);
      return size;
   }
}

/**
 * The key_type struct is used to store the binary representation of a key.
 */
struct key_type : private std::vector<char> {
   key_type() = default;

   explicit key_type(std::vector<char>&& v) : std::vector<char>(v) {}

   key_type(char* str, size_t size) : std::vector<char>(str, str+size) {}

   key_type operator+(const key_type& b) const {
      key_type ret = *this;
      ret += b;
      return ret;
   }

   key_type& operator+=(const key_type& b) {
      this->insert(this->end(), b.begin(), b.end());
      return *this;
   }

   static key_type from_hex( const std::string_view& str ) {
      key_type out;

      check( str.size() % 2 == 0, "invalid hex string length" );
      out.reserve( str.size() / 2 );

      auto start = str.data();
      auto end   = start + str.size();
      for(const char* p = start; p != end; p+=2 ) {
          auto hic = p[0];
          auto lowc = p[1];

          uint8_t hi  = hic  <= '9' ? hic-'0' : 10+(hic-'a');
          uint8_t low = lowc <= '9' ? lowc-'0' : 10+(lowc-'a');

          out.push_back( char((hi << 4) | low) );
      }

      return out;
   }

   std::string to_hex() const {
      const char* hex_characters = "0123456789abcdef";

      uint32_t buffer_size = 2 * size();
      check(buffer_size >= size(), "length passed into printhex is too large");

      void* buffer = buffer_size > detail::max_stack_buffer_size ? malloc(buffer_size) : alloca(buffer_size);

      char* b = reinterpret_cast<char*>(buffer);
      const uint8_t* d = reinterpret_cast<const uint8_t*>(data());
      for(uint32_t i = 0; i < size(); ++i) {
         *b = hex_characters[d[i] >> 4];
         ++b;
         *b = hex_characters[d[i] & 0x0f];
         ++b;
      }

      std::string ret{reinterpret_cast<char*>(buffer), buffer_size};

      if (buffer_size > detail::max_stack_buffer_size) {
         free(buffer);
      }

      return ret;
   }

   using std::vector<char>::data;
   using std::vector<char>::size;
   using std::vector<char>::resize;
};

/* @cond PRIVATE */
template <typename T>
inline key_type make_key(T&& t) {
   return key_type(convert_to_key(std::forward<T>(t)));
}

inline key_type make_prefix(eosio::name table_name, eosio::name index_name, uint8_t status = 1) {
   return make_key(std::make_tuple(status, table_name, index_name));
}

inline key_type table_key(const key_type& prefix, const key_type& key) {
   return prefix + key;
}
/* @endcond */

// This is the "best" way to document a function that does not technically exist using Doxygen.
#if EOSIO_CDT_DOXYGEN
/**
 * @brief A function for converting types to the appropriate binary representation for the EOSIO Key Value database.
 * @details The CDT provides implementations of this function for many of the common primitives and for structs/tuples.
 * If sticking with standard types, contract developers should not need to interact with this function.
 * If doing something more advanced, contract developers may need to provide their own implementation for a special type.
 */
template <typename T>
inline key_type make_key(T val) {
   return {};
}
#endif

static constexpr eosio::name kv_ram = "eosio.kvram"_n;
static constexpr eosio::name kv_disk = "eosio.kvdisk"_n;

struct default_constructor_tag;

/**
 * @defgroup keyvalue Key Value Table
 * @ingroup contracts
 *
 * @brief Defines an EOSIO Key Value Table
 * @details EOSIO Key Value API provides a C++ interface to the EOSIO Key Value database.
 * Key Value Tables require 1 primary index, of any type that can be serialized to a binary representation.
 * Key Value Tables support 0 or more secondary index, of any type that can be serialized to a binary representation.
 * Indexes must be a member variable or a member function.
 *
 * @tparam T         - the type of the data stored as the value of the table
  */
template<typename T>
class kv_table {

   class kv_index;

   class iterator {
   public:
      enum class status {
         iterator_ok     = 0,  // Iterator is positioned at a key-value pair
         iterator_erased = -1, // The key-value pair that the iterator used to be positioned at was erased
         iterator_end    = -2, // Iterator is out-of-bounds
      };

      iterator() = default;

      iterator(uint32_t itr, status itr_stat, const kv_index* index) : itr{itr}, itr_stat{itr_stat}, index{index} {}

      iterator(iterator&& other) :
         itr(std::exchange(other.itr, 0)),
         itr_stat(std::move(other.itr_stat))
      {}

      ~iterator() {
         if (itr) {
            index->tbl->environment.kv_it_destroy(itr);
         }
      }

      iterator& operator=(iterator&& other) {
         if (itr) {
            index->tbl->environment.kv_it_destroy(itr);
         }
         itr = std::exchange(other.itr, 0);
         itr_stat = std::move(other.itr_stat);
         return *this;
      }

      bool good()const { return itr_stat != status::iterator_end; }

      /**
       * Returns the value that the iterator points to.
       * @ingroup keyvalue
       *
       * @return The value that the iterator points to.
       */
      T value() const {
         using namespace detail;

         eosio::check(itr_stat != status::iterator_end, "Cannot read end iterator");

         uint32_t value_size;
         uint32_t actual_value_size;
         uint32_t actual_data_size;
         uint32_t offset = 0;

         // call once to get the value_size
         index->tbl->environment.kv_it_value(itr, 0, (char*)nullptr, 0, value_size);

         void* buffer = value_size > detail::max_stack_buffer_size ? malloc(value_size) : alloca(value_size);
         auto stat = index->tbl->environment.kv_it_value(itr, offset, (char*)buffer, value_size, actual_value_size);

         eosio::check(static_cast<status>(stat) == status::iterator_ok, "Error reading value");

         void* deserialize_buffer = buffer;
         size_t deserialize_size = actual_value_size;

         bool is_primary = index->index_name == index->tbl->primary_index_name;
         if (!is_primary) {
            auto success = index->tbl->environment.kv_get(index->tbl->db_name, index->contract_name.value, (char*)buffer, actual_value_size, actual_data_size);
            eosio::check(success, "failure getting primary key in `value()`");

            void* pk_buffer = actual_data_size > detail::max_stack_buffer_size ? malloc(actual_data_size) : alloca(actual_data_size);
            index->tbl->environment.kv_get_data(index->tbl->db_name, 0, (char*)pk_buffer, actual_data_size);

            deserialize_buffer = pk_buffer;
            deserialize_size = actual_data_size;
         }

         T val;
         detail::deserialize(val, deserialize_buffer, deserialize_size);

         if (value_size > detail::max_stack_buffer_size) {
            free(buffer);
         }

         if (!is_primary && actual_data_size > detail::max_stack_buffer_size) {
            free(deserialize_buffer);
         }
         return val;
      }

      key_type key() const {
         uint32_t actual_value_size;
         uint32_t value_size;

         // call once to get the value size
         index->tbl->environment.kv_it_key(itr, 0, (char*)nullptr, 0, value_size);

         void* buffer = value_size > detail::max_stack_buffer_size ? malloc(value_size) : alloca(value_size);
         auto stat = index->tbl->environment.kv_it_key(itr, 0, (char*)buffer, value_size, actual_value_size);

         eosio::check(static_cast<status>(stat) == status::iterator_ok, "Error getting key");

         return {(char*)buffer, actual_value_size};
      }

      iterator& operator++() {
         eosio::check(itr_stat != status::iterator_end, "cannot increment end iterator");
         itr_stat = static_cast<status>(index->tbl->environment.kv_it_next(itr));
         return *this;
      }

      iterator& operator--() {
         if (!itr) {
            itr = index->tbl->environment.kv_it_create(index->tbl->db_name, index->contract_name.value, index->prefix.data(), index->prefix.size());
         }
         itr_stat = static_cast<status>(index->tbl->environment.kv_it_prev(itr));
         eosio::check(itr_stat != status::iterator_end, "decremented past the beginning");
         return *this;
      }

      int32_t key_compare(key_type kt) const {
         if (itr == 0 || itr_stat == status::iterator_end) {
            return 1;
         } else {
            return index->tbl->environment.kv_it_key_compare(itr, kt.data(), kt.size());
         }
      }

      bool operator==(const iterator& b) const {
         return compare(b) == 0;
      }

      bool operator!=(const iterator& b) const {
         return compare(b) != 0;
      }

      bool operator<(const iterator& b) const {
         return compare(b) < 0;
      }

      bool operator<=(const iterator& b) const {
         return compare(b) <= 0;
      }

      bool operator>(const iterator& b) const {
         return compare(b) > 0;
      }

      bool operator>=(const iterator& b) const {
         return compare(b) >= 0;
      }

      explicit operator bool() {
         return compare(this) != 0;
      }

   private:
      uint32_t itr;
      status itr_stat;

      const kv_index* index;

      int compare(const iterator& b) const {
         bool a_is_end = !itr || itr_stat == status::iterator_end;
         bool b_is_end = !b.itr || b.itr_stat == status::iterator_end;
         if (a_is_end && b_is_end) {
            return 0;
         } else if (a_is_end && b.itr) {
            return 1;
         } else if (itr && b_is_end) {
            return -1;
         } else {
            return index->tbl->environment.kv_it_compare(itr, b.itr);
         }
      }
   };

   class kv_index {

   public:
      eosio::name index_name;
      eosio::name table_name;
      eosio::name contract_name;

      key_type to_table_key( const key_type& k )const{ return table_key( prefix, k ); }

   protected:
      kv_index() = default;

      template <typename KF>
      kv_index(eosio::name index_name, KF&& kf) : index_name{index_name} {
         key_function = [=](const T& t) {
            return make_key(std::invoke(kf, &t));
         };
      }

      key_type get_key(const T& inst) const { return key_function(inst); }
      kv_table* tbl;
      key_type prefix;

   private:
      friend kv_table;

      std::function<key_type(const T&)> key_function;

      virtual void setup() = 0;
   };

public:

   using iterator = kv_table::iterator;
   using value_type = T;

   /**
    * @ingroup keyvalue
    *
    * @brief Defines an index on an EOSIO Key Value Table
    * @details A Key Value Index allows a user of the table to search based on a given field.
    * The only restrictions on that field are that it is serializable to a binary representation sortable by the KV intrinsics.
    * Convenience functions exist to handle most of the primitive types as well as some more complex types, and are
    * used automatically where possible.
    *
    * @tparam K - The type of the key used in the index.
    */
   template <typename K>
   class index : public kv_index {
   public:
      using kv_table<T>::kv_index::tbl;
      using kv_table<T>::kv_index::table_name;
      using kv_table<T>::kv_index::contract_name;
      using kv_table<T>::kv_index::index_name;
      using kv_table<T>::kv_index::prefix;

      template <typename KF>
      index(eosio::name name, KF&& kf) : kv_index{name, kf} {
         static_assert(std::is_same_v<K, std::remove_cv_t<std::decay_t<decltype(std::invoke(kf, std::declval<const T*>()))>>>,
               "Make sure the variable/function passed to the constructor returns the same type as the template parameter.");
      }

      /**
       * Search for an existing object in a table by the index, using the given key.
       * @ingroup keyvalue
       *
       * @param key - The key to search for.
       * @return An iterator to the found object OR the `end` iterator if the given key was not found.
       */
      iterator find(const K& key) const {
         auto t_key = table_key(prefix, make_key(key));

         return find(t_key);
      }

      iterator find(const key_type& key) const {
         uint32_t itr = tbl->environment.kv_it_create(tbl->db_name, contract_name.value, prefix.data(), prefix.size());
         int32_t itr_stat = tbl->environment.kv_it_lower_bound(itr, key.data(), key.size());

         auto cmp = tbl->environment.kv_it_key_compare(itr, key.data(), key.size());

         if (cmp != 0) {
            tbl->environment.kv_it_destroy(itr);
            return end();
         }

         return {itr, static_cast<typename iterator::status>(itr_stat), this};
      }

      /**
       * Check if a given key exists in the index.
       * @ingroup keyvalue
       *
       * @param key - The key to check for.
       * @return If the key exists or not.
       */
      bool exists(const K& key) const {
         auto t_key = table_key(prefix, make_key(key));
         return exists(t_key);
      }

      bool exists(const key_type& key) const {
         uint32_t value_size;
         return tbl->environment.kv_get(tbl->db_name, contract_name.value, key.data(), key.size(), value_size);
      }

      /**
       * Get the value for an existing object in a table by the index, using the given key.
       * @ingroup keyvalue
       *
       * @param key - The key to search for.
       * @return The value corresponding to the key.
       */
      T operator[](const K& key) const {
         return operator[](make_key(key));
      }

      T operator[](const key_type& key) const {
         auto opt = get(key);
         eosio::check(opt, __FILE__ ":" + std::to_string(__LINE__) + " Key not found in `[]`");
         return *opt;
      }

      /**
       * Get the value for an existing object in a table by the index, using the given key.
       * @ingroup keyvalue
       *
       * @param key - The key to search for.
       * @return A std::optional of the value corresponding to the key.
       */
      std::optional<T> get(const K& key) const {
         return get(make_key(key));
      }

      std::optional<T> get(const key_type& k ) const {
         auto key =   table_key( prefix, k );
         uint32_t value_size;
         uint32_t actual_data_size;
         std::optional<T> ret_val;

         auto success = tbl->environment.kv_get(tbl->db_name, contract_name.value, key.data(), key.size(), value_size);
         if (!success) {
            return ret_val;
         }

         void* buffer = value_size > detail::max_stack_buffer_size ? malloc(value_size) : alloca(value_size);
         auto copy_size = tbl->environment.kv_get_data(tbl->db_name, 0, (char*)buffer, value_size);

         void* deserialize_buffer = buffer;
         size_t deserialize_size = copy_size;

         bool is_primary = index_name == tbl->primary_index_name;
         if (!is_primary) {
            auto success = tbl->environment.kv_get(tbl->db_name, contract_name.value, (char*)buffer, copy_size, actual_data_size);
            eosio::check(success, "failure getting primary key");

            void* pk_buffer = actual_data_size > detail::max_stack_buffer_size ? malloc(actual_data_size) : alloca(actual_data_size);
            auto pk_copy_size = tbl->environment.kv_get_data(tbl->db_name, 0, (char*)pk_buffer, actual_data_size);

            deserialize_buffer = pk_buffer;
            deserialize_size = pk_copy_size;
         }

         ret_val.emplace();
         detail::deserialize(*ret_val, deserialize_buffer, deserialize_size);

         if (value_size > detail::max_stack_buffer_size) {
            free(buffer);
         }

         if (is_primary && actual_data_size > detail::max_stack_buffer_size) {
            free(deserialize_buffer);
         }

         return ret_val;
      }

      /**
       * Returns an iterator to the object with the lowest key (by this index) in the table.
       * @ingroup keyvalue
       *
       * @return An iterator to the object with the lowest key (by this index) in the table.
       */
      iterator begin() const {
         uint32_t itr = tbl->environment.kv_it_create(tbl->db_name, contract_name.value, prefix.data(), prefix.size());
         int32_t itr_stat = tbl->environment.kv_it_lower_bound(itr, "", 0);

         return {itr, static_cast<typename iterator::status>(itr_stat), this};
      }

      /**
       * Returns an iterator pointing past the end. It does not point to any element, therefore `value` should not be called on it.
       * @ingroup keyvalue
       *
       * @return An iterator pointing past the end.
       */
      iterator end() const {
         return {0, iterator::status::iterator_end, this};
      }

      /**
       * Returns an iterator pointing to the element with the lowest key greater than or equal to the given key.
       * @ingroup keyvalue
       *
       * @return An iterator pointing to the element with the lowest key greater than or equal to the given key.
       */
      iterator lower_bound(const K& key) const {
         return lower_bound(make_key(key));
      }

      iterator lower_bound(const key_type& k ) const {
         auto key = table_key( prefix, k );
         uint32_t itr = tbl->environment.kv_it_create(tbl->db_name, contract_name.value, prefix.data(), prefix.size());
         int32_t itr_stat = tbl->environment.kv_it_lower_bound(itr, key.data(), key.size());

         return {itr, static_cast<typename iterator::status>(itr_stat), this};
      }

      /**
       * Returns an iterator pointing to the first element greater than the given key.
       * @ingroup keyvalue
       *
       * @return An iterator pointing to the first element greater than the given key.
       */
      iterator upper_bound(const K& key) const {
         return upper_bound(make_key(key));
      }

      iterator upper_bound(const key_type& key) const {
         auto it = lower_bound(key);

         auto cmp = it.key_compare(key);
         if (cmp == 0) {
            ++it;
         }

         return it;
      }

      /**
       * Returns a vector of objects that fall between the specifed range. The range is inclusive, exclusive.
       * @ingroup keyvalue
       *
       * @param begin - The beginning of the range (inclusive).
       * @param end - The end of the range (exclusive).
       * @return A vector containing all the objects that fall between the range.
       */
      std::vector<T> range(const K& b, const K& e) const {
         return range(make_key(b), make_key(e));
      }

      std::vector<T> range(const key_type& b_key, const key_type& e_key) const {
         auto b = table_key(prefix, make_key(b_key));
         auto e = table_key(prefix, make_key(e_key));
         std::vector<T> return_values;

         for(auto itr = lower_bound(b), end_itr = lower_bound(e); itr < end_itr; ++itr) {
            return_values.push_back(itr.value());
         }

         return return_values;
      }

      void setup() override {
         prefix = make_prefix(table_name, index_name);
      }
   };

   /**
    * @ingroup keyvalue
    * Puts a value into the table. If the value already exists, it updates the existing entry.
    * The key is determined from the defined primary index.
    * If the put attempts to store over an existing secondary index, the transaction will be aborted.
    *
    * @param value - The entry to be stored in the table.
    */
   void put(const T& value) {
      uint32_t value_size;
      T old_value;

      auto primary_key = primary_index->get_key(value);
      auto tbl_key = table_key(make_prefix(table_name, primary_index->index_name), primary_key);

      auto primary_key_found = environment.kv_get(db_name, contract_name.value, tbl_key.data(), tbl_key.size(), value_size);

      if (primary_key_found) {
         void* buffer = value_size > detail::max_stack_buffer_size ? malloc(value_size) : alloca(value_size);
         auto copy_size = environment.kv_get_data(db_name, 0, (char*)buffer, value_size);

         detail::deserialize(old_value, buffer, copy_size);

         if (value_size > detail::max_stack_buffer_size) {
            free(buffer);
         }
      }

      for (const auto& idx : secondary_indices) {
         auto sec_tbl_key = table_key(make_prefix(table_name, idx->index_name), idx->get_key(value));
         auto sec_found = environment.kv_get(db_name, contract_name.value, sec_tbl_key.data(), sec_tbl_key.size(), value_size);

         if (!primary_key_found) {
            eosio::check(!sec_found, "Attempted to store an existing secondary index.");
            environment.kv_set(db_name, contract_name.value, sec_tbl_key.data(), sec_tbl_key.size(), tbl_key.data(), tbl_key.size());
         } else {
            if (sec_found) {
               void* buffer = value_size > detail::max_stack_buffer_size ? malloc(value_size) : alloca(value_size);
               auto copy_size = environment.kv_get_data(db_name, 0, (char*)buffer, value_size);

               auto res = memcmp(buffer, tbl_key.data(), copy_size);
               eosio::check(copy_size == tbl_key.size() && res == 0, "Attempted to update an existing secondary index.");

               if (copy_size > detail::max_stack_buffer_size) {
                  free(buffer);
               }
            } else {
               auto old_sec_key = table_key(make_prefix(table_name, idx->index_name), idx->get_key(old_value));
               environment.kv_erase(db_name, contract_name.value, old_sec_key.data(), old_sec_key.size());
               environment.kv_set(db_name, contract_name.value, sec_tbl_key.data(), sec_tbl_key.size(), tbl_key.data(), tbl_key.size());
            }
         }

      }

      size_t data_size = detail::get_size(value);
      void* data_buffer = data_size > detail::max_stack_buffer_size ? malloc(data_size) : alloca(data_size);

      detail::serialize(value, data_buffer, data_size);

      environment.kv_set(db_name, contract_name.value, tbl_key.data(), tbl_key.size(), (const char*)data_buffer, data_size);

      if (data_size > detail::max_stack_buffer_size) {
         free(data_buffer);
      }
   }

   /**
    * Removes a value from the table.
    * @ingroup keyvalue
    *
    * @param key - The key of the value to be removed.
    */
   void erase(const T& value) {
      uint32_t value_size;

      auto primary_key = primary_index->get_key(value);
      auto tbl_key = table_key(make_prefix(table_name, primary_index->index_name), primary_key);
      auto primary_key_found = environment.kv_get(db_name, contract_name.value, tbl_key.data(), tbl_key.size(), value_size);

      if (!primary_key_found) {
         return;
      }

      for (const auto& idx : secondary_indices) {
         auto sec_tbl_key = table_key(make_prefix(table_name, idx->index_name), idx->get_key(value));
         environment.kv_erase(db_name, contract_name.value, sec_tbl_key.data(), sec_tbl_key.size());
      }

      environment.kv_erase(db_name, contract_name.value, tbl_key.data(), tbl_key.size());
   }

protected:
   kv_table() = default;

   kv_environment environment;

   kv_table(kv_environment environment) : environment{std::move(environment)} {}

   kv_table(const kv_table&) = delete;
   kv_table(kv_table&&)      = delete;

   template <typename I>
   void setup_indices(I& index) {
      kv_index* idx = &index;
      idx->contract_name = contract_name;
      idx->table_name = table_name;
      idx->tbl = this;

      idx->setup();
      secondary_indices.push_back(idx);
   }

   template <typename PrimaryIndex, typename... SecondaryIndices>
   void init(eosio::name contract, eosio::name table, eosio::name db, PrimaryIndex& prim_index, SecondaryIndices&... indices) {
      validate_types(prim_index);
      (validate_types(indices), ...);

      contract_name = contract;
      table_name = table;
      db_name = db.value;

      primary_index = &prim_index;
      primary_index->contract_name = contract_name;
      primary_index->table_name = table_name;
      primary_index->tbl = this;

      primary_index->setup();

      primary_index_name = primary_index->index_name;

      (setup_indices(indices), ...);
   }

private:
   eosio::name contract_name;
   eosio::name table_name;
   uint64_t db_name;

   eosio::name primary_index_name;

   kv_index* primary_index;
   std::vector<kv_index*> secondary_indices;

   constexpr void validate_types() {}

   template <typename Type>
   constexpr void validate_types(Type& t) {
      constexpr bool is_kv_index = std::is_base_of_v<kv_index, std::decay_t<Type>>;
      static_assert(is_kv_index, "Incorrect type passed to init. Must be a reference to an index.");
   }

};

template <typename T, eosio::name::raw SingletonName, eosio::name::raw DbName = "eosio.kvram"_n>
class kv_singleton {
   kv_environment environment;

   struct state {
      T value;
      char* raw_original;
      size_t raw_original_size;

      bool is_dirty = false;
      bool is_cached = false;

      ~state() {
         if (raw_original_size) {
            free(raw_original);
         }
      }
   };

public:
   using value_type = T;

   explicit kv_singleton(eosio::name contract_name, bool write_on_destruct) : contract_name{contract_name}, write_on_destruct{write_on_destruct} {
      key = make_prefix();
   }

   kv_singleton(eosio::name contract_name, kv_environment environment, bool write_on_destruct) : environment{environment}, contract_name{contract_name}, write_on_destruct{write_on_destruct} {}

   ~kv_singleton() {
      if (get_state().is_dirty && write_on_destruct) {
         store();
      }
   }

   const T& get() {
      auto& ste = get_state();
      if (!ste.is_cached) {
         uint32_t copy_size;
         uint32_t value_size;

         auto success = environment.kv_get(db_name, contract_name.value, key.data(), key.size(), value_size);

         eosio::check(success, "tried to get a singleton that does not exist");

         ste.raw_original = (char*)malloc(value_size);
         ste.raw_original_size = value_size;
         copy_size = environment.kv_get_data(db_name, 0, ste.raw_original, value_size);

         detail::deserialize(ste.value, ste.raw_original, copy_size);
         ste.is_cached = true;
      }

      return get_state().value;
   }

   void set(const T& val) {
      auto& ste = get_state();
      ste.value = val;
      ste.is_dirty = true;
      ste.is_cached = true;
   }

   bool exists() {
      uint32_t value_size;

      return environment.kv_get(db_name, contract_name.value, key.data(), key.size(), value_size);
   }

   void erase() {
      environment.kv_erase(db_name, contract_name.value, key.data(), key.size());
      auto& ste = get_state();
      ste.is_cached = false;
      ste.is_dirty = false;
      ste.raw_original_size = 0;
      free(ste.raw_original);
   }

   void store() {
      auto& ste = get_state();
      if (ste.is_dirty) {
         size_t data_size = detail::get_size(ste.value);
         void* data_buffer = data_size > detail::max_stack_buffer_size ? malloc(data_size) : alloca(data_size);

         detail::serialize(ste.value, data_buffer, data_size);

         if (ste.raw_original_size != data_size || memcmp(ste.raw_original, data_buffer, data_size) != 0) {
            environment.kv_set(db_name, contract_name.value, key.data(), key.size(), (const char*)data_buffer, data_size);
         }
      }
   }

private:
   constexpr static uint64_t db_name = static_cast<uint64_t>(DbName);
   constexpr static uint64_t singleton_name = static_cast<uint64_t>(SingletonName);

   eosio::name contract_name;
   bool write_on_destruct;
   key_type key;

   key_type make_prefix() {
      return make_key(std::make_tuple(0x02, singleton_name));
   }

   state& get_state() {
      static state value;
      return value;
   }
};

} // eosio
