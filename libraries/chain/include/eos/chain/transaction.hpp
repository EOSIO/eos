/*
 * Copyright (c) 2017, Respective Authors.
 *
 * The MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#pragma once
#include <eos/chain/types.hpp>
#include <eos/chain/message.hpp>

#include <numeric>

namespace eos { namespace chain {

   /**
    * @defgroup transactions Transactions
    *
    * All transactions are sets of messages that must be applied atomically (all succeed or all fail). Transactions
    * must refer to a recent block that defines the context of the operation so that they assert a known
    * state-precondition assumed by the transaction signers.
    *
    * Rather than specify a full block number, we only specify the lower 16 bits of the block number which means you
    * can reference any block within the last 65,536 blocks which is 2.2 days with a 3 second block interval.
    *
    * All transactions must expire so that the network does not have to maintain a permanent record of all transactions
    * ever published. A transaction may not have an expiration date too far in the future because this would require
    * keeping too much transaction history in memory.
    *
    * The block prefix is the first 4 bytes of the block hash of the reference block number, which is the second 4
    * bytes of the @ref block_id_type (the first 4 bytes of the block ID are the block number)
    *
    * @note It is not recommended to set the @ref ref_block_num, @ref ref_block_prefix, and @ref expiration
    * fields manually. Call @ref set_expiration instead.
    *
    * @{
    */

   /**
    * @brief A generated_transaction is a transaction which was internally generated by the blockchain, typically as a
    * result of running a contract.
    *
    * When contracts run and seek to interact with other contracts, or mutate chain state, they generate transactions
    * containing messages which effect these interactions and mutations. These generated transactions are automatically
    * generated by contracts, and thus are authorized by the script that generated them rather than by signatures. The
    * generated_transaction struct records such a transaction.
    *
    * These transactions are generated while processing other transactions. The generated transactions are assigned a
    * sequential ID, then stored in the block that generated them. These generated transactions can then be included in
    * subsequent blocks by referencing this ID.
    */
   struct GeneratedTransaction : public Transaction {
      generated_transaction_id_type id;

      digest_type merkle_digest() const;
   };

   /**
    * @brief A transaction with signatures
    *
    * signed_transaction is a transaction with an additional manifest of authorizations included with the transaction,
    * and the signatures backing those authorizations.
    */
   struct SignedTransaction : public types::SignedTransaction {
      using types::SignedTransaction::SignedTransaction;

      /// Calculate the digest for a transaction
      digest_type         digest()const;
      transaction_id_type id()const;
      /// Calculate the digest used for signature validation
      digest_type         sig_digest(const chain_id_type& chain_id)const;

      void set_reference_block(const block_id_type& reference_block);
      bool verify_reference_block(const block_id_type& reference_block)const;

      /** signs and appends to signatures */
      const signature_type& sign(const private_key_type& key, const chain_id_type& chain_id);

      /** returns signature but does not append */
      signature_type sign(const private_key_type& key, const chain_id_type& chain_id)const;

      flat_set<public_key_type> get_signature_keys(const chain_id_type& chain_id)const;

      template <typename T>
      void setMessage(int messageIndex, const types::FuncName& type, T&& value) {
         Message m(messages[messageIndex]);
         m.set(type, std::forward<T>(value));
         messages[messageIndex] = m;
      }
      template <typename T>
      T messageAs(int messageIndex) {
         Message m(messages[messageIndex]);
         return m.as<T>();
      }
      template <typename... Args>
      void emplaceMessage(Args&&... a) {
         messages.emplace_back(Message(std::forward<Args>(a)...));
      }

      /**
       * Removes all messages, signatures, and authorizations
       */
      void clear() { messages.clear(); signatures.clear(); authorizations.clear(); }

      digest_type merkle_digest()const;
   };

   struct ProcessedTransaction;
   struct NotifyOutput;


   /**
    *  Output generated by applying a particular message.
    */
   struct MessageOutput {
      vector<NotifyOutput>         notify; ///< accounts to notify, may only be notified once
      vector<ProcessedTransaction> sync_transactions; ///< transactions generated and applied after notify
      vector<GeneratedTransaction> async_transactions; ///< transactions generated but not applied
   };

   struct NotifyOutput {
      AccountName   name;
      MessageOutput output;
   };

   struct ProcessedTransaction : public SignedTransaction {
      explicit ProcessedTransaction( const SignedTransaction& t ):SignedTransaction(t){}
      ProcessedTransaction(){}

      vector<MessageOutput> output;
   };

   /**
    * @brief This class aids in checking that a transaction is properly authorized, and that no unnecessary
    * authorizations are present in it.
    *
    * In order for a transaction to be valid, it must declare the permissions it requires to execute all of its
    * contained messages (@see SignedTransaction::authorizations). The blockchain can verify that the transaction bears
    * signatures necessary and sufficient to satisfy its declared permissions before the transaction is executed;
    * however, the blockchain cannot know whether the declared permissions are necessary and sufficient to authorize
    * the transaction until the transaction is fully executed. This is because the permissions required is a
    * contract-layer concern, so the way we discover what permissions are required is by executing the messages, and as
    * the message handlers execute, they assert that certain permissions are required.
    *
    * This class takes the list of declared permissions provided by a transaction at construction. As the transaction
    * is subsequently executed, and the message handlers assert that permissions are required, and these required
    * permissions can be passed to @ref requirePermission which will verify that the declared permissions satisfy the
    * required permissions. This class also tracks which of the declared permissions have been used to satisfy a
    * permission passed to @ref requirePermission and which ones have not.
    *
    * When the transaction is finished executing, call @ref allPermissionsUsed to determine whether any declared
    * permissions were unnecessary to fully authorize the transaction.
    */
   class TransactionAuthorizationChecker {
   public:
      using ParentGetter = std::function<fc::optional<types::AccountPermission>(const types::AccountPermission&)>;

      /**
       * @param declaredPermissions The permissions declared by the transaction as necessary and sufficient to
       * authorize it
       * @param getParentPermission A callable which takes a @ref types::AccountPermission and returns its parent, or
       * an empty optional if no parent exists
       */
      TransactionAuthorizationChecker(const vector<types::AccountPermission>& declaredPermissions,
                                      ParentGetter getParentPermission)
         : declaredPermissions(declaredPermissions), getParentPermission(getParentPermission) {}

      bool requirePermission(const types::AccountPermission& permission) {
         auto Matches = [](const types::AccountPermission& permission) {
            return [&permission](const types::AccountPermission& other) {
               return permission.account == other.account && permission.permission == other.permission;
            };
         };

         auto itr = std::find_if(declaredPermissions.begin(), declaredPermissions.end(), Matches(permission));
         if (itr != declaredPermissions.end()) {
            usedPermissions[itr - declaredPermissions.begin()] = true;
            return true;
         }

         auto parent = getParentPermission(permission);
         while (parent) {
            itr = std::find_if(declaredPermissions.begin(), declaredPermissions.end(), Matches(*parent));
            if (itr != declaredPermissions.end()) {
               usedPermissions[itr - declaredPermissions.begin()] = true;
               return true;
            }
            parent = getParentPermission(*parent);
         }

         return false;
      }

      bool allPermissionsUsed() const {
         return std::all_of(usedPermissions.begin(), usedPermissions.end(), [](bool b){return b;});
      }

   private:
      /// The list of permissions declared by the transaction
      const vector<types::AccountPermission> declaredPermissions;
      /// Parallel to @ref declaredPermissions; usedPermissions[N] is true iff declaredPermissions[N] has been required
      vector<bool> usedPermissions = vector<bool>(declaredPermissions.size(), false);

      ParentGetter getParentPermission;
   };

   /// @} transactions group

} } // eos::chain

FC_REFLECT(eos::chain::GeneratedTransaction, (id))
FC_REFLECT_DERIVED(eos::chain::SignedTransaction, (eos::types::SignedTransaction), )
FC_REFLECT(eos::chain::MessageOutput, (notify)(sync_transactions)(async_transactions) )
FC_REFLECT_DERIVED(eos::chain::ProcessedTransaction, (eos::types::SignedTransaction), (output) )
FC_REFLECT(eos::chain::NotifyOutput, (name)(output) )
