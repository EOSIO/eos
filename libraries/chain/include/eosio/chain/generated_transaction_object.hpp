/**
 *  @file
 *  @copyright defined in eos/LICENSE
 */
#pragma once
#include <eosio/chain/config.hpp>
#include <eosio/chain/database_utils.hpp>

#include <eosio/chain/transaction.hpp>
#include <fc/uint128.hpp>

#include <boost/multi_index/mem_fun.hpp>

#include <eosio/chain/multi_index_includes.hpp>

namespace eosio { namespace chain {
   /**
    * The purpose of this object is to store transactions generated by processing the
    * transactions included in the chain.  These transactions should be treated like
    * authentic/valid SignedTransactions for the purposes of scheduling transactions
    * in to new blocks
    */
   class generated_transaction_object : public cyberway::chaindb::object<generated_transaction_object_type, generated_transaction_object>
   {
         CHAINDB_OBJECT_ID_CTOR(generated_transaction_object)

         id_type                       id;
         transaction_id_type           trx_id;
         account_name                  sender;
         uint128_t                     sender_id = 0; /// ID given this transaction by the sender
         time_point                    delay_until; /// this generated transaction will not be applied until the specified time
         time_point                    expiration; /// this generated transaction will not be applied after this time
         time_point                    published;
         string                        packed_trx;

         uint32_t set( const transaction& trx ) {
            auto trxsize = fc::raw::pack_size( trx );
            packed_trx.resize( trxsize );
            fc::datastream<char*> ds( const_cast<char*>(packed_trx.data()), trxsize );
            fc::raw::pack( ds, trx );
            return trxsize;
         }
   };

   struct by_trx_id;
   struct by_expiration;
   struct by_delay;
   struct by_status;
   struct by_sender_id;

   using generated_transaction_table = cyberway::chaindb::table_container<
      generated_transaction_object,
      cyberway::chaindb::indexed_by<
         cyberway::chaindb::ordered_unique< cyberway::chaindb::tag<by_id>, BOOST_MULTI_INDEX_MEMBER(generated_transaction_object, generated_transaction_object::id_type, id)>,
         cyberway::chaindb::ordered_unique< cyberway::chaindb::tag<by_trx_id>, BOOST_MULTI_INDEX_MEMBER( generated_transaction_object, transaction_id_type, trx_id)>,
         cyberway::chaindb::ordered_unique< cyberway::chaindb::tag<by_expiration>,
            cyberway::chaindb::composite_key< generated_transaction_object,
               BOOST_MULTI_INDEX_MEMBER( generated_transaction_object, time_point, expiration),
               BOOST_MULTI_INDEX_MEMBER( generated_transaction_object, generated_transaction_object::id_type, id)
            >
         >,
         cyberway::chaindb::ordered_unique< cyberway::chaindb::tag<by_delay>,
            cyberway::chaindb::composite_key< generated_transaction_object,
               BOOST_MULTI_INDEX_MEMBER( generated_transaction_object, time_point, delay_until),
               BOOST_MULTI_INDEX_MEMBER( generated_transaction_object, generated_transaction_object::id_type, id)
            >
         >,
         cyberway::chaindb::ordered_unique< cyberway::chaindb::tag<by_sender_id>,
            cyberway::chaindb::composite_key< generated_transaction_object,
               BOOST_MULTI_INDEX_MEMBER( generated_transaction_object, account_name, sender),
               BOOST_MULTI_INDEX_MEMBER( generated_transaction_object, uint128_t, sender_id)
            >
         >
      >
   >;

   class generated_transaction
   {
      public:
         generated_transaction(const generated_transaction_object& gto)
         :trx_id(gto.trx_id)
         ,sender(gto.sender)
         ,sender_id(gto.sender_id)
         ,delay_until(gto.delay_until)
         ,expiration(gto.expiration)
         ,published(gto.published)
         ,packed_trx(gto.packed_trx.begin(), gto.packed_trx.end())
         {}

         generated_transaction(const generated_transaction& gt) = default;
         generated_transaction(generated_transaction&& gt) = default;
         generated_transaction() = default;

         transaction_id_type           trx_id;
         account_name                  sender;
         uint128_t                     sender_id;
         time_point                    delay_until; /// this generated transaction will not be applied until the specified time
         time_point                    expiration; /// this generated transaction will not be applied after this time
         time_point                    published;
         vector<char>                  packed_trx;

   };

   namespace config {
      template<>
      struct billable_size<generated_transaction_object> {
         static const uint64_t overhead = overhead_per_row_per_index_ram_bytes * 5;  ///< overhead for 5x indices internal-key, txid, expiration, delay, sender_id
         static const uint64_t value = 96 + 4 + overhead; ///< 96 bytes for our constant size fields, 4 bytes for a varint for packed_trx size and 96 bytes of implementation overhead
      };
   }
} } // eosio::chain

CHAINDB_SET_TABLE_TYPE(eosio::chain::generated_transaction_object, eosio::chain::generated_transaction_table)
CHAINDB_TAG(eosio::chain::generated_transaction_object, gtransaction)
FC_REFLECT(eosio::chain::generated_transaction_object, (id)(trx_id)(sender)(sender_id)(delay_until)(expiration)(published)(packed_trx))
FC_REFLECT(eosio::chain::generated_transaction, (trx_id)(sender)(sender_id)(delay_until)(expiration)(published)(packed_trx))
