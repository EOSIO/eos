<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EOS.IO: benchmark</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="eos-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EOS.IO
   &#160;<span id="projectnumber">DAWN 3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">benchmark </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://travis-ci.org/google/benchmark"></a> <a href="https://ci.appveyor.com/project/google/benchmark/branch/master"></a> <a href="https://coveralls.io/r/google/benchmark"></a></p>
<p><a class="el" href="struct_a.html">A</a> library to support the benchmarking of functions, similar to unit-tests.</p>
<p>Discussion group: <a href="https://groups.google.com/d/forum/benchmark-discuss">https://groups.google.com/d/forum/benchmark-discuss</a></p>
<p>IRC channel: <a href="https://freenode.net">https://freenode.net</a> #googlebenchmark</p>
<p><a href="#known-issues">Known issues and common problems</a></p>
<p><a class="el" href="tools_8md.html">Additional Tooling Documentation</a></p>
<h2>Example usage</h2>
<h3>Basic usage</h3>
<p>Define a function that executes the code to be measured.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">static void BM_StringCreation(benchmark::State&amp; state) {</div><div class="line">  while (state.KeepRunning())</div><div class="line">    std::string empty_string;</div><div class="line">}</div><div class="line">// Register the function as a benchmark</div><div class="line">BENCHMARK(BM_StringCreation);</div><div class="line"></div><div class="line">// Define another benchmark</div><div class="line">static void BM_StringCopy(benchmark::State&amp; state) {</div><div class="line">  std::string x = &quot;hello&quot;;</div><div class="line">  while (state.KeepRunning())</div><div class="line">    std::string copy(x);</div><div class="line">}</div><div class="line">BENCHMARK(BM_StringCopy);</div><div class="line"></div><div class="line">BENCHMARK_MAIN();</div></div><!-- fragment --><h3>Passing arguments</h3>
<p>Sometimes a family of benchmarks can be implemented with just one routine that takes an extra argument to specify which one of the family of benchmarks to run. For example, the following code defines a family of benchmarks for measuring the speed of <code><a class="el" href="musl_2upstream_2include_2string_8h.html#aee1e7ce4792f4aa3f195319f81109a45">memcpy()</a></code> calls of different lengths:</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">static void BM_memcpy(benchmark::State&amp; state) {</div><div class="line">  char* src = new char[state.range(0)];</div><div class="line">  char* dst = new char[state.range(0)];</div><div class="line">  memset(src, &#39;x&#39;, state.range(0));</div><div class="line">  while (state.KeepRunning())</div><div class="line">    memcpy(dst, src, state.range(0));</div><div class="line">  state.SetBytesProcessed(int64_t(state.iterations()) *</div><div class="line">                          int64_t(state.range(0)));</div><div class="line">  delete[] src;</div><div class="line">  delete[] dst;</div><div class="line">}</div><div class="line">BENCHMARK(BM_memcpy)-&gt;Arg(8)-&gt;Arg(64)-&gt;Arg(512)-&gt;Arg(1&lt;&lt;10)-&gt;Arg(8&lt;&lt;10);</div></div><!-- fragment --><p>The preceding code is quite repetitive, and can be replaced with the following short-hand. The following invocation will pick a few appropriate arguments in the specified range and will generate a benchmark for each such argument.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">BENCHMARK(BM_memcpy)-&gt;Range(8, 8&lt;&lt;10);</div></div><!-- fragment --><p>By default the arguments in the range are generated in multiples of eight and the command above selects [ 8, 64, 512, 4k, 8k ]. In the following code the range multiplier is changed to multiples of two.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">BENCHMARK(BM_memcpy)-&gt;RangeMultiplier(2)-&gt;Range(8, 8&lt;&lt;10);</div></div><!-- fragment --><p> Now arguments generated are [ 8, 16, 32, 64, 128, 256, 512, 1024, 2k, 4k, 8k ].</p>
<p>You might have a benchmark that depends on two or more inputs. For example, the following code defines a family of benchmarks for measuring the speed of set insertion.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">static void BM_SetInsert(benchmark::State&amp; state) {</div><div class="line">  while (state.KeepRunning()) {</div><div class="line">    state.PauseTiming();</div><div class="line">    std::set&lt;int&gt; data = ConstructRandomSet(state.range(0));</div><div class="line">    state.ResumeTiming();</div><div class="line">    for (int j = 0; j &lt; state.range(1); ++j)</div><div class="line">      data.insert(RandomNumber());</div><div class="line">  }</div><div class="line">}</div><div class="line">BENCHMARK(BM_SetInsert)</div><div class="line">    -&gt;Args({1&lt;&lt;10, 1})</div><div class="line">    -&gt;Args({1&lt;&lt;10, 8})</div><div class="line">    -&gt;Args({1&lt;&lt;10, 64})</div><div class="line">    -&gt;Args({1&lt;&lt;10, 512})</div><div class="line">    -&gt;Args({8&lt;&lt;10, 1})</div><div class="line">    -&gt;Args({8&lt;&lt;10, 8})</div><div class="line">    -&gt;Args({8&lt;&lt;10, 64})</div><div class="line">    -&gt;Args({8&lt;&lt;10, 512});</div></div><!-- fragment --><p>The preceding code is quite repetitive, and can be replaced with the following short-hand. The following macro will pick a few appropriate arguments in the product of the two specified ranges and will generate a benchmark for each such pair.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">BENCHMARK(BM_SetInsert)-&gt;Ranges({{1&lt;&lt;10, 8&lt;&lt;10}, {1, 512}});</div></div><!-- fragment --><p>For more complex patterns of inputs, passing a custom function to <code>Apply</code> allows programmatic specification of an arbitrary set of arguments on which to run the benchmark. The following example enumerates a dense range on one parameter, and a sparse range on the second.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">static void CustomArguments(benchmark::internal::Benchmark* b) {</div><div class="line">  for (int i = 0; i &lt;= 10; ++i)</div><div class="line">    for (int j = 32; j &lt;= 1024*1024; j *= 8)</div><div class="line">      b-&gt;Args({i, j});</div><div class="line">}</div><div class="line">BENCHMARK(BM_SetInsert)-&gt;Apply(CustomArguments);</div></div><!-- fragment --><h3>Calculate asymptotic complexity (Big O)</h3>
<p>Asymptotic complexity might be calculated for a family of benchmarks. The following code will calculate the coefficient for the high-order term in the running time and the normalized root-mean square error of string comparison.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">static void BM_StringCompare(benchmark::State&amp; state) {</div><div class="line">  std::string s1(state.range(0), &#39;-&#39;);</div><div class="line">  std::string s2(state.range(0), &#39;-&#39;);</div><div class="line">  while (state.KeepRunning()) {</div><div class="line">    benchmark::DoNotOptimize(s1.compare(s2));</div><div class="line">  }</div><div class="line">  state.SetComplexityN(state.range(0));</div><div class="line">}</div><div class="line">BENCHMARK(BM_StringCompare)</div><div class="line">    -&gt;RangeMultiplier(2)-&gt;Range(1&lt;&lt;10, 1&lt;&lt;18)-&gt;Complexity(benchmark::oN);</div></div><!-- fragment --><p>As shown in the following invocation, asymptotic complexity might also be calculated automatically.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">BENCHMARK(BM_StringCompare)</div><div class="line">    -&gt;RangeMultiplier(2)-&gt;Range(1&lt;&lt;10, 1&lt;&lt;18)-&gt;Complexity();</div></div><!-- fragment --><p>The following code will specify asymptotic complexity with a lambda function, that might be used to customize high-order term calculation.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">BENCHMARK(BM_StringCompare)-&gt;RangeMultiplier(2)</div><div class="line">    -&gt;Range(1&lt;&lt;10, 1&lt;&lt;18)-&gt;Complexity([](int n)-&gt;double{return n; });</div></div><!-- fragment --><h3>Templated benchmarks</h3>
<p>Templated benchmarks work the same way: This example produces and consumes messages of size <code>sizeof(v)</code> <code>range_x</code> times. It also outputs throughput in the absence of multiprogramming.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">template &lt;class Q&gt; int BM_Sequential(benchmark::State&amp; state) {</div><div class="line">  Q q;</div><div class="line">  typename Q::value_type v;</div><div class="line">  while (state.KeepRunning()) {</div><div class="line">    for (int i = state.range(0); i--; )</div><div class="line">      q.push(v);</div><div class="line">    for (int e = state.range(0); e--; )</div><div class="line">      q.Wait(&amp;v);</div><div class="line">  }</div><div class="line">  // actually messages, not bytes:</div><div class="line">  state.SetBytesProcessed(</div><div class="line">      static_cast&lt;int64_t&gt;(state.iterations())*state.range(0));</div><div class="line">}</div><div class="line">BENCHMARK_TEMPLATE(BM_Sequential, WaitQueue&lt;int&gt;)-&gt;Range(1&lt;&lt;0, 1&lt;&lt;10);</div></div><!-- fragment --><p><a class="el" href="struct_three.html">Three</a> macros are provided for adding benchmark templates.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">#if __cplusplus &gt;= 201103L // C++11 and greater.</div><div class="line">#define BENCHMARK_TEMPLATE(func, ...) // Takes any number of parameters.</div><div class="line">#else // C++ &lt; C++11</div><div class="line">#define BENCHMARK_TEMPLATE(func, arg1)</div><div class="line">#endif</div><div class="line">#define BENCHMARK_TEMPLATE1(func, arg1)</div><div class="line">#define BENCHMARK_TEMPLATE2(func, arg1, arg2)</div></div><!-- fragment --><h2>Passing arbitrary arguments to a benchmark</h2>
<p>In C++11 it is possible to define a benchmark that takes an arbitrary number of extra arguments. The <code>BENCHMARK_CAPTURE(func, test_case_name, ...args)</code> macro creates a benchmark that invokes <code>func</code> with the <code><a class="el" href="classbenchmark_1_1_state.html">benchmark::State</a></code> as the first argument followed by the specified <code>args...</code>. The <code>test_case_name</code> is appended to the name of the benchmark and should describe the values passed.</p>
<p>``<code>c++ template &lt;class ...ExtraArgs&gt;</code> void BM_takes_args(<a class="el" href="classbenchmark_1_1_state.html">benchmark::State</a>&amp; state, ExtraArgs&amp;&amp;... extra_args) { [...] } // Registers a benchmark named "BM_takes_args/int_string_test<code>that passes // the specified values to</code>extra_args`. BENCHMARK_CAPTURE(BM_takes_args, int_string_test, 42, std::string("abc")); </p><div class="fragment"><div class="line">Note that elements of `...args` may refer to global variables. Users should</div><div class="line">avoid modifying global state inside of a benchmark.</div><div class="line"></div><div class="line">## Using RegisterBenchmark(name, fn, args...)</div><div class="line"></div><div class="line">The `RegisterBenchmark(name, func, args...)` function provides an alternative</div><div class="line">way to create and register benchmarks.</div><div class="line">`RegisterBenchmark(name, func, args...)` creates, registers, and returns a</div><div class="line">pointer to a new benchmark with the specified `name` that invokes</div><div class="line">`func(st, args...)` where `st` is a `benchmark::State` object.</div><div class="line"></div><div class="line">Unlike the `BENCHMARK` registration macros, which can only be used at the global</div><div class="line">scope, the `RegisterBenchmark` can be called anywhere. This allows for</div><div class="line">benchmark tests to be registered programmatically.</div><div class="line"></div><div class="line">Additionally `RegisterBenchmark` allows any callable object to be registered</div><div class="line">as a benchmark. Including capturing lambdas and function objects. This</div><div class="line">allows the creation</div><div class="line"></div><div class="line">For Example:</div><div class="line">```c++</div><div class="line">auto BM_test = [](benchmark::State&amp; st, auto Inputs) { /* ... */ };</div><div class="line"></div><div class="line">int main(int argc, char** argv) {</div><div class="line">  for (auto&amp; test_input : { /* ... */ })</div><div class="line">      benchmark::RegisterBenchmark(test_input.name(), BM_test, test_input);</div><div class="line">  benchmark::Initialize(&amp;argc, argv);</div><div class="line">  benchmark::RunSpecifiedBenchmarks();</div><div class="line">}</div></div><!-- fragment --><h3>Multithreaded benchmarks</h3>
<p>In a multithreaded test (benchmark invoked by multiple threads simultaneously), it is guaranteed that none of the threads will start until all have called <code>KeepRunning</code>, and all will have finished before KeepRunning returns false. As such, any global setup or teardown can be wrapped in a check against the thread index:</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">static void BM_MultiThreaded(benchmark::State&amp; state) {</div><div class="line">  if (state.thread_index == 0) {</div><div class="line">    // Setup code here.</div><div class="line">  }</div><div class="line">  while (state.KeepRunning()) {</div><div class="line">    // Run the test as normal.</div><div class="line">  }</div><div class="line">  if (state.thread_index == 0) {</div><div class="line">    // Teardown code here.</div><div class="line">  }</div><div class="line">}</div><div class="line">BENCHMARK(BM_MultiThreaded)-&gt;Threads(2);</div></div><!-- fragment --><p>If the benchmarked code itself uses threads and you want to compare it to single-threaded code, you may want to use real-time ("wallclock") measurements for latency comparisons:</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">BENCHMARK(BM_test)-&gt;Range(8, 8&lt;&lt;10)-&gt;UseRealTime();</div></div><!-- fragment --><p>Without <code>UseRealTime</code>, CPU time is used by default.</p>
<h2>Manual timing</h2>
<p>For benchmarking something for which neither CPU time nor real-time are correct or accurate enough, completely manual timing is supported using the <code>UseManualTime</code> function.</p>
<p>When <code>UseManualTime</code> is used, the benchmarked code must call <code>SetIterationTime</code> once per iteration of the <code>KeepRunning</code> loop to report the manually measured time.</p>
<p>An example use case for this is benchmarking GPU execution (e.g. OpenCL or CUDA kernels, OpenGL or Vulkan or Direct3D draw calls), which cannot be accurately measured using CPU time or real-time. Instead, they can be measured accurately using a dedicated API, and these measurement results can be reported back with <code>SetIterationTime</code>.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">static void BM_ManualTiming(benchmark::State&amp; state) {</div><div class="line">  int microseconds = state.range(0);</div><div class="line">  std::chrono::duration&lt;double, std::micro&gt; sleep_duration {</div><div class="line">    static_cast&lt;double&gt;(microseconds)</div><div class="line">  };</div><div class="line"></div><div class="line">  while (state.KeepRunning()) {</div><div class="line">    auto start = std::chrono::high_resolution_clock::now();</div><div class="line">    // Simulate some useful workload with a sleep</div><div class="line">    std::this_thread::sleep_for(sleep_duration);</div><div class="line">    auto end   = std::chrono::high_resolution_clock::now();</div><div class="line"></div><div class="line">    auto elapsed_seconds =</div><div class="line">      std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(</div><div class="line">        end - start);</div><div class="line"></div><div class="line">    state.SetIterationTime(elapsed_seconds.count());</div><div class="line">  }</div><div class="line">}</div><div class="line">BENCHMARK(BM_ManualTiming)-&gt;Range(1, 1&lt;&lt;17)-&gt;UseManualTime();</div></div><!-- fragment --><h3>Preventing optimisation</h3>
<p>To prevent a value or expression from being optimized away by the compiler the <code><a class="el" href="namespacebenchmark.html#a23ac1f8548a2caa6d33932f366d262b6">benchmark::DoNotOptimize</a>(...)</code> and <code>benchmark::ClobberMemory()</code> functions can be used.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">static void BM_test(benchmark::State&amp; state) {</div><div class="line">  while (state.KeepRunning()) {</div><div class="line">      int x = 0;</div><div class="line">      for (int i=0; i &lt; 64; ++i) {</div><div class="line">        benchmark::DoNotOptimize(x += i);</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><code>DoNotOptimize(&lt;expr&gt;)</code> forces the <em>result</em> of <code>&lt;expr&gt;</code> to be stored in either memory or a register. For GNU based compilers it acts as read/write barrier for global memory. More specifically it forces the compiler to flush pending writes to memory and reload any other values as necessary.</p>
<p>Note that <code>DoNotOptimize(&lt;expr&gt;)</code> does not prevent optimizations on <code>&lt;expr&gt;</code> in any way. <code>&lt;expr&gt;</code> may even be removed entirely when the result is already known. For example:</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">  /* Example 1: `&lt;expr&gt;` is removed entirely. */</div><div class="line">  int foo(int x) { return x + 42; }</div><div class="line">  while (...) DoNotOptimize(foo(0)); // Optimized to DoNotOptimize(42);</div><div class="line"></div><div class="line">  /*  Example 2: Result of &#39;&lt;expr&gt;&#39; is only reused */</div><div class="line">  int bar(int) __attribute__((const));</div><div class="line">  while (...) DoNotOptimize(bar(0)); // Optimized to:</div><div class="line">  // int __result__ = bar(0);</div><div class="line">  // while (...) DoNotOptimize(__result__);</div></div><!-- fragment --><p>The second tool for preventing optimizations is <code>ClobberMemory()</code>. In essence <code>ClobberMemory()</code> forces the compiler to perform all pending writes to global memory. Memory managed by block scope objects must be "escaped" using <code>DoNotOptimize(...)</code> before it can be clobbered. In the below example <code>ClobberMemory()</code> prevents the call to <code>v.push_back(42)</code> from being optimized away.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">static void BM_vector_push_back(benchmark::State&amp; state) {</div><div class="line">  while (state.KeepRunning()) {</div><div class="line">    std::vector&lt;int&gt; v;</div><div class="line">    v.reserve(1);</div><div class="line">    benchmark::DoNotOptimize(v.data()); // Allow v.data() to be clobbered.</div><div class="line">    v.push_back(42);</div><div class="line">    benchmark::ClobberMemory(); // Force 42 to be written to memory.</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>Note that <code>ClobberMemory()</code> is only available for GNU or MSVC based compilers.</p>
<h3>Set time unit manually</h3>
<p>If a benchmark runs a few milliseconds it may be hard to visually compare the measured times, since the output data is given in nanoseconds per default. In order to manually set the time unit, you can specify it manually:</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">BENCHMARK(BM_test)-&gt;Unit(benchmark::kMillisecond);</div></div><!-- fragment --><h2>Controlling number of iterations</h2>
<p>In all cases, the number of iterations for which the benchmark is run is governed by the amount of time the benchmark takes. Concretely, the number of iterations is at least one, not more than 1e9, until CPU time is greater than the minimum time, or the wallclock time is 5x minimum time. The minimum time is set as a flag <code>--benchmark_min_time</code> or per benchmark by calling <code>MinTime</code> on the registered benchmark object.</p>
<h2>Reporting the mean and standard devation by repeated benchmarks</h2>
<p>By default each benchmark is run once and that single result is reported. However benchmarks are often noisy and a single result may not be representative of the overall behavior. For this reason it's possible to repeatedly rerun the benchmark.</p>
<p>The number of runs of each benchmark is specified globally by the <code>--benchmark_repetitions</code> flag or on a per benchmark basis by calling <code>Repetitions</code> on the registered benchmark object. When a benchmark is run more than once the mean and standard deviation of the runs will be reported.</p>
<p>Additionally the <code>--benchmark_report_aggregates_only={true|false}</code> flag or <code>ReportAggregatesOnly(bool)</code> function can be used to change how repeated tests are reported. By default the result of each repeated run is reported. When this option is 'true' only the mean and standard deviation of the runs is reported. Calling <code>ReportAggregatesOnly(bool)</code> on a registered benchmark object overrides the value of the flag for that benchmark.</p>
<h2>Fixtures</h2>
<p>Fixture tests are created by first defining a type that derives from <a class="el" href="classbenchmark_1_1_fixture.html">benchmark::Fixture</a> and then creating/registering the tests using the following macros:</p>
<ul>
<li><code><a class="el" href="benchmark__api_8h.html#a2884177eef37d9ba4aff427cb3be186c">BENCHMARK_F(ClassName, Method)</a></code></li>
<li><code><a class="el" href="benchmark__api_8h.html#a0039ddd9b71ced4dc28e87a932e06b72">BENCHMARK_DEFINE_F(ClassName, Method)</a></code></li>
<li><code><a class="el" href="benchmark__api_8h.html#a5f8e8e48e0fec94b83fc52c3b24b5dc0">BENCHMARK_REGISTER_F(ClassName, Method)</a></code></li>
</ul>
<p>For Example:</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">class MyFixture : public benchmark::Fixture {};</div><div class="line"></div><div class="line">BENCHMARK_F(MyFixture, FooTest)(benchmark::State&amp; st) {</div><div class="line">   while (st.KeepRunning()) {</div><div class="line">     ...</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line">BENCHMARK_DEFINE_F(MyFixture, BarTest)(benchmark::State&amp; st) {</div><div class="line">   while (st.KeepRunning()) {</div><div class="line">     ...</div><div class="line">  }</div><div class="line">}</div><div class="line">/* BarTest is NOT registered */</div><div class="line">BENCHMARK_REGISTER_F(MyFixture, BarTest)-&gt;Threads(2);</div><div class="line">/* BarTest is now registered */</div></div><!-- fragment --><h2>User-defined counters</h2>
<p>You can add your own counters with user-defined names. The example below will add columns "Foo", "Bar" and "Baz" in its output:</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">static void UserCountersExample1(benchmark::State&amp; state) {</div><div class="line">  double numFoos = 0, numBars = 0, numBazs = 0;</div><div class="line">  while (state.KeepRunning()) {</div><div class="line">    // ... count Foo,Bar,Baz events</div><div class="line">  }</div><div class="line">  state.counters[&quot;Foo&quot;] = numFoos;</div><div class="line">  state.counters[&quot;Bar&quot;] = numBars;</div><div class="line">  state.counters[&quot;Baz&quot;] = numBazs;</div><div class="line">}</div></div><!-- fragment --><p>The <code>state.counters</code> object is a <code><a class="el" href="classstd_1_1map.html">std::map</a></code> with <code>std::string</code> keys and <code><a class="el" href="class_counter.html">Counter</a></code> values. The latter is a <code>double</code>-like class, via an implicit conversion to <code>double&amp;</code>. Thus you can use all of the standard arithmetic assignment operators (<code>=,+=,-=,*=,/=</code>) to change the value of each counter.</p>
<p>In multithreaded benchmarks, each counter is set on the calling thread only. When the benchmark finishes, the counters from each thread will be summed; the resulting sum is the value which will be shown for the benchmark.</p>
<p>The <code><a class="el" href="class_counter.html">Counter</a></code> constructor accepts two parameters: the value as a <code>double</code> and a bit flag which allows you to show counters as rates and/or as per-thread averages:</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">  // sets a simple counter</div><div class="line">  state.counters[&quot;Foo&quot;] = numFoos;</div><div class="line"></div><div class="line">  // Set the counter as a rate. It will be presented divided</div><div class="line">  // by the duration of the benchmark.</div><div class="line">  state.counters[&quot;FooRate&quot;] = Counter(numFoos, benchmark::Counter::kIsRate);</div><div class="line"></div><div class="line">  // Set the counter as a thread-average quantity. It will</div><div class="line">  // be presented divided by the number of threads.</div><div class="line">  state.counters[&quot;FooAvg&quot;] = Counter(numFoos, benchmark::Counter::kAvgThreads);</div><div class="line"></div><div class="line">  // There&#39;s also a combined flag:</div><div class="line">  state.counters[&quot;FooAvgRate&quot;] = Counter(numFoos,benchmark::Counter::kAvgThreadsRate);</div></div><!-- fragment --><p>When you're compiling in C++11 mode or later you can use <code>insert()</code> with <code>std::initializer_list</code>:</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">  // With C++11, this can be done:</div><div class="line">  state.counters.insert({{&quot;Foo&quot;, numFoos}, {&quot;Bar&quot;, numBars}, {&quot;Baz&quot;, numBazs}});</div><div class="line">  // ... instead of:</div><div class="line">  state.counters[&quot;Foo&quot;] = numFoos;</div><div class="line">  state.counters[&quot;Bar&quot;] = numBars;</div><div class="line">  state.counters[&quot;Baz&quot;] = numBazs;</div></div><!-- fragment --><h2>Exiting Benchmarks in Error</h2>
<p>When errors caused by external influences, such as file I/O and network communication, occur within a benchmark the <code>State::SkipWithError(const char* msg)</code> function can be used to skip that run of benchmark and report the error. Note that only future iterations of the <code><a class="el" href="race__condition_8pass_8cpp.html#a66a88b763994a9c04935d5fcc24c22ca">KeepRunning()</a></code> are skipped. Users may explicitly return to exit the benchmark immediately.</p>
<p>The <code>SkipWithError(...)</code> function may be used at any point within the benchmark, including before and after the <code><a class="el" href="race__condition_8pass_8cpp.html#a66a88b763994a9c04935d5fcc24c22ca">KeepRunning()</a></code> loop.</p>
<p>For example:</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">static void BM_test(benchmark::State&amp; state) {</div><div class="line">  auto resource = GetResource();</div><div class="line">  if (!resource.good()) {</div><div class="line">      state.SkipWithError(&quot;Resource is not good!&quot;);</div><div class="line">      // KeepRunning() loop will not be entered.</div><div class="line">  }</div><div class="line">  while (state.KeepRunning()) {</div><div class="line">      auto data = resource.read_data();</div><div class="line">      if (!resource.good()) {</div><div class="line">        state.SkipWithError(&quot;Failed to read data!&quot;);</div><div class="line">        break; // Needed to skip the rest of the iteration.</div><div class="line">     }</div><div class="line">     do_stuff(data);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2>Running a subset of the benchmarks</h2>
<p>The <code>--benchmark_filter=&lt;regex&gt;</code> option can be used to only run the benchmarks which match the specified <code>&lt;regex&gt;</code>. For example:</p>
<div class="fragment"><div class="line">$ ./run_benchmarks.x --benchmark_filter=BM_memcpy/32</div><div class="line">Run on (1 X 2300 MHz CPU )</div><div class="line">2016-06-25 19:34:24</div><div class="line">Benchmark              Time           CPU Iterations</div><div class="line">----------------------------------------------------</div><div class="line">BM_memcpy/32          11 ns         11 ns   79545455</div><div class="line">BM_memcpy/32k       2181 ns       2185 ns     324074</div><div class="line">BM_memcpy/32          12 ns         12 ns   54687500</div><div class="line">BM_memcpy/32k       1834 ns       1837 ns     357143</div></div><!-- fragment --><h2>Output Formats</h2>
<p>The library supports multiple output formats. Use the <code>--benchmark_format=&lt;console|json|csv&gt;</code> flag to set the format type. <code>console</code> is the default format.</p>
<p>The Console format is intended to be a human readable format. By default the format generates color output. Context is output on stderr and the tabular data on stdout. Example tabular output looks like: </p><div class="fragment"><div class="line">Benchmark                               Time(ns)    CPU(ns) Iterations</div><div class="line">----------------------------------------------------------------------</div><div class="line">BM_SetInsert/1024/1                        28928      29349      23853  133.097kB/s   33.2742k items/s</div><div class="line">BM_SetInsert/1024/8                        32065      32913      21375  949.487kB/s   237.372k items/s</div><div class="line">BM_SetInsert/1024/10                       33157      33648      21431  1.13369MB/s   290.225k items/s</div></div><!-- fragment --><p>The JSON format outputs human readable json split into two top level attributes. The <code>context</code> attribute contains information about the run in general, including information about the CPU and the date. The <code>benchmarks</code> attribute contains a list of ever benchmark run. Example json output looks like: </p><div class="fragment"><div class="line">{</div><div class="line">  &quot;context&quot;: {</div><div class="line">    &quot;date&quot;: &quot;2015/03/17-18:40:25&quot;,</div><div class="line">    &quot;num_cpus&quot;: 40,</div><div class="line">    &quot;mhz_per_cpu&quot;: 2801,</div><div class="line">    &quot;cpu_scaling_enabled&quot;: false,</div><div class="line">    &quot;build_type&quot;: &quot;debug&quot;</div><div class="line">  },</div><div class="line">  &quot;benchmarks&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;BM_SetInsert/1024/1&quot;,</div><div class="line">      &quot;iterations&quot;: 94877,</div><div class="line">      &quot;real_time&quot;: 29275,</div><div class="line">      &quot;cpu_time&quot;: 29836,</div><div class="line">      &quot;bytes_per_second&quot;: 134066,</div><div class="line">      &quot;items_per_second&quot;: 33516</div><div class="line">    },</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;BM_SetInsert/1024/8&quot;,</div><div class="line">      &quot;iterations&quot;: 21609,</div><div class="line">      &quot;real_time&quot;: 32317,</div><div class="line">      &quot;cpu_time&quot;: 32429,</div><div class="line">      &quot;bytes_per_second&quot;: 986770,</div><div class="line">      &quot;items_per_second&quot;: 246693</div><div class="line">    },</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;BM_SetInsert/1024/10&quot;,</div><div class="line">      &quot;iterations&quot;: 21393,</div><div class="line">      &quot;real_time&quot;: 32724,</div><div class="line">      &quot;cpu_time&quot;: 33355,</div><div class="line">      &quot;bytes_per_second&quot;: 1199226,</div><div class="line">      &quot;items_per_second&quot;: 299807</div><div class="line">    }</div><div class="line">  ]</div><div class="line">}</div></div><!-- fragment --><p>The CSV format outputs comma-separated values. The <code>context</code> is output on stderr and the CSV itself on stdout. Example CSV output looks like: </p><div class="fragment"><div class="line">name,iterations,real_time,cpu_time,bytes_per_second,items_per_second,label</div><div class="line">&quot;BM_SetInsert/1024/1&quot;,65465,17890.7,8407.45,475768,118942,</div><div class="line">&quot;BM_SetInsert/1024/8&quot;,116606,18810.1,9766.64,3.27646e+06,819115,</div><div class="line">&quot;BM_SetInsert/1024/10&quot;,106365,17238.4,8421.53,4.74973e+06,1.18743e+06,</div></div><!-- fragment --><h2>Output Files</h2>
<p>The library supports writing the output of the benchmark to a file specified by <code>--benchmark_out=&lt;filename&gt;</code>. The format of the output can be specified using <code>--benchmark_out_format={json|console|csv}</code>. Specifying <code>--benchmark_out</code> does not suppress the console output.</p>
<h2>Debug vs Release</h2>
<p>By default, benchmark builds as a debug library. You will see a warning in the output when this is the case. To build it as a release library instead, use:</p>
<div class="fragment"><div class="line">cmake -DCMAKE_BUILD_TYPE=Release</div></div><!-- fragment --><p>To enable link-time optimisation, use</p>
<div class="fragment"><div class="line">cmake -DCMAKE_BUILD_TYPE=Release -DBENCHMARK_ENABLE_LTO=true</div></div><!-- fragment --><h2>Linking against the library</h2>
<p>When using gcc, it is necessary to link against pthread to avoid runtime exceptions. This is due to how gcc implements std::thread. See <a href="https://github.com/google/benchmark/issues/67">issue #67</a> for more details.</p>
<h2>Compiler Support</h2>
<p>Google Benchmark uses C++11 when building the library. As such we require a modern C++ toolchain, both compiler and standard library.</p>
<p>The following minimum versions are strongly recommended build the library:</p>
<ul>
<li>GCC 4.8</li>
<li>Clang 3.4</li>
<li>Visual Studio 2013</li>
<li>Intel 2015 Update 1</li>
</ul>
<p>Anything older <em>may</em> work.</p>
<p>Note: Using the library and its headers in C++03 is supported. C++11 is only required to build the library.</p>
<h1>Known Issues</h1>
<h3>Windows</h3>
<ul>
<li>Users must manually link <code>shlwapi.lib</code>. Failure to do so may result in unresolved symbols. </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
